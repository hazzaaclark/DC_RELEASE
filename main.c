/* COPYRIGHT (C) HARRY CLARK 2024 */

/* DREAMCAST ROM TOOLKIT */

/* THIS FILE PERTAINS TOWARDS THE FUNCTIONALTIY REGARDING */
/* ROM FILES AND THEIR UNDERLYING ARCHITECTURE */

/* SUCH IS THE CASE WITH THIS LITTLE TOOL, THIS FILE WILL BE THE */
/* FOR ALL OF THE INFORMATION PERTAINING TOWARDS THE RELEASE DATE ON THE HEADER */

/* NESTED INCLUDES */

#include "ROM.h"

#undef USE_ROM_PRAGMAS

/* ALLOCATE THE DESIGNATED MEMORY FOR THE ROM BUFFER */
/* ASSUME A STACK SIZE OF 16 BYTES TO DISCERN THE SIZE OF THE BUFFER INITIALLY */

char* ROM_BUFFER(const char* RELEASE, char *BUFFER)
{
    strncpy(BUFFER, RELEASE + 3, 16);
    BUFFER[16] = '\0';
    return BUFFER;
}

/* AFTER THE INTIAL ROM STACK INSTANTIATION */
/* THE PROGRAM WILL BEGIN TO SCAN THROUGH THE HEADER TO EVALUATE */ 
/* THE RELEASE DATE BASED ON THE BUFFER */

void ROM_PROC_OPTION(const char* RELEASE)
{
    char RELEASE_BUFFER[17];
    ROM_BUFFER(RELEASE, RELEASE_BUFFER);

    fprintf(stdout, "Domestic Release Date: %s\n", RELEASE_BUFFER);
}

/* DISCERN THE RANGE OF OFFSETS TO SEARCH FOR THE DESIGNATED SIGNATURE */
/* THIS IS ASSUMING THAT WE DON'T HAVE CURRENT INFORMATION PERTAINING TOWARDS */
/* THE SPECIFIC CHAR */

int ROM_HEADER_OFFSET()
{
    struct ROM_OPTION* ROM_BASE;

    /* BASED ON THE OVERALL SIZE OF THE OFFSET, IN RELATION TO THE START AND END */
    /* WE ASSUME THIS ARBITRARY LENGTH IN ORDER TO DISCERN WHERE ON THE HEADER TO LOOK FOR */

    for(ROM_BASE->ROM_OFFSET = ROM_BASE->ROM_START; ROM_BASE->ROM_OFFSET <= ROM_BASE->ROM_END; ROM_BASE->ROM_OFFSET++)
    {
        /* WHEN THE LENGTH HAS BEEN DISCERNED, NULL TERMINATE THE STRING TO REDUCE TYPE COMPLEXITY */

        char* RELEASE_LENGTH[17];
        memcpy(RELEASE_LENGTH, ROM_BASE->FILES.ROM_FILE_HEADER + ROM_BASE->ROM_OFFSET, 16);
        RELEASE_LENGTH[16] = '\0';

        ROM_PROC_OPTION(RELEASE_LENGTH);
        return EXIT_SUCCESS;
    }

    fprintf(stderr, "Unable to find a valid release signature in the Header\n");
    return EXIT_FAILURE;
}

int main(int argc, char* argv[])
{
    struct ROM_OPTION* ROM_BASE;

    /* CHECK TO SEE IF THE CORRECT ARGS ARE PRESENT */

    if(argc != 2)
    {
        printf("Usage: %s <ROM file path>\n", argv[0]);
        return EXIT_FAILURE;
    }

    ROM_BASE->FILES.ROM_FILE = fopen(argv[1], "rb");
    
    if(ROM_BASE->FILES.ROM_FILE == NULL)
    {
        fprintf(stderr, "No Dreamcast ROM file was found\n");
        return EXIT_FAILURE;
    }

    
    /* READ THE ROM HEADER, SET THE SEEK START METHOD TO BE AT THE ORIGIN */
    /* FROM THERE, DISCERN HOW MANY BYTES NEED TO BE READ IN ORDER TO GET TO THE ENCLOSED RELEASE DATE LOGIC */

    fseek(ROM_BASE->FILES.ROM_FILE, 0, SEEK_SET);
    ROM_BASE->ROM_BYTES = fread(ROM_BASE->FILES.ROM_FILE_HEADER, 1, MAX_ROM_HEADER_SIZE, ROM_BASE->FILES.ROM_FILE);

    if(ROM_BASE->ROM_BYTES != MAX_ROM_HEADER_SIZE)
    {
        fprintf(stderr, "Failed to read ROM Header %x\n");
        fclose(ROM_BASE->FILES.ROM_FILE);
        return EXIT_FAILURE;
    }

    fclose(ROM_BASE->FILES.ROM_FILE);

    ROM_HEADER_OFFSET();

}
